rawurlencode() {
	local string="${1}"
	local strlen=${#string}
	local encoded=""
	local pos c o

	for (( pos=0 ; pos<strlen ; pos++ )); do
		c=${string:$pos:1}
		case "$c" in
			[-_.~a-zA-Z0-9] ) o="${c}" ;;
			* )   printf -v o '%%%02x' "'$c"
		esac
		encoded+="${o}"
	done
	echo "${encoded}"
}

# usage: `layout postgres`
# on first run creates new postgres cluster
# you can run `postgres` to start it and `psql` to connect
layout_postgres() {
	PGDATA="$(direnv_layout_dir)/postgres"
	PGHOST="$PGDATA"
	PGHOST_ESCAPED=$(rawurlencode "$PGHOST")
	DATABASE_URL="postgresql://$PGHOST_ESCAPED/$USER"
	export PGDATA
	export PGHOST
	export PGHOST_ESCAPED
	export DATABASE_URL

	if [[ ! -d "$PGDATA" ]]; then
		log_status "initing local postgres"
		mkdir -p "$PGDATA"
		chmod 0750 "$PGDATA"
		LANG="en_US.UTF-8" LC_ALL="en_US.UTF-8" LC_CTYPE="en_US.UTF-8" initdb
		cat >> "$PGDATA/postgresql.conf" <<-EOF
			listen_addresses = ''
			unix_socket_directories = '$PGHOST'
			fsync = off
			synchronous_commit = off
			full_page_writes = off
		EOF
		echo "CREATE DATABASE $USER;" | postgres --single -E postgres
		echo ""
	fi
}

# usage: `layout redis`
# on first run creates new redis server directory
# you can run `redis-server $REDIS_CONFIG` to start it
layout_redis() {
	REDIS_DATA="$(direnv_layout_dir)/redis"
	REDIS_CONFIG="$REDIS_DATA/redis.conf"
	REDIS_SOCKET="$REDIS_DATA/redis.sock"
	export REDIS_DATA
	export REDIS_CONFIG
	export REDIS_SOCKET

	if [[ ! -d "$REDIS_DATA" ]]; then
		log_status "initing local redis"
		mkdir -p "$REDIS_DATA"
		chmod 0750 "$REDIS_DATA"
		cat >> "$REDIS_DATA/redis.conf" <<-EOF
			bind 127.0.0.1
			port 0
			unixsocket $REDIS_SOCKET
			unixsocketperm 700
			pidfile $REDIS_DATA/redis.pid
			loglevel notice
			logfile ""
			save 900 1
			save 300 10
			save 60 10000
			stop-writes-on-bgsave-error no
			rdbcompression yes
			dbfilename dump.rdb
			dir $REDIS_DATA/
		EOF
	fi
}

# usage: `layout codeartifact mydomain myrepo aws-region owner-id`
# On first run fetch aws codeartifact token and place it into .direnv/codeartifact_token
# if .direnv/codeartifact_token was modified more than 9 hours ago then it will be updated with new token
# Also creates in-project .npmrc with settings for `repo`
# and populate env with $CODEARTIFACT_TOKEN var
layout_codeartifact() {
	local tokenfile
	mkdir -p "$(direnv_layout_dir)"
	tokenfile="$(direnv_layout_dir)/codeartifact_token"
	if [ ! -f "$tokenfile" ] || [[ $(find "$tokenfile" -mmin +540 -print) ]]; then
		local domain=${1}
		local repo=${2}
		local region=${3:-$AWS_REGION}
		if [[ -z $domain ]] || [[ -z $repo ]] || [[ -z $region ]]; then
			log_error "'domain', 'repo' and 'region' are required arguments."
			return 1
		fi
		if [[ -z ${4} ]]; then
			local owner=""
		else
			local owner="--domain-owner ${4}"
		fi
		log_status "refreshing codeartifact token"
		local token
		# shellcheck disable=SC2086
		token=$(aws codeartifact get-authorization-token --domain "$domain" --region "$region" $owner | jq -r .authorizationToken)
		if [[ -z $token ]]; then
			return 1
		fi
		echo "$token" > "$tokenfile"
		tee "$PWD/.npmrc" <<-EOF > /dev/null
		@${repo}:registry=https://${domain}.amazonaws.com/npm/${repo}/
		//${domain}.amazonaws.com/npm/${repo}/:always-auth=true
		//${domain}.amazonaws.com/npm/${repo}/:${token}
		EOF
	fi
	watch_file "$tokenfile"
	CODEARTIFACT_TOKEN=$(cat "$tokenfile")
	export CODEARTIFACT_TOKEN
}
# vim: noexpandtab ts=4 ft=sh
